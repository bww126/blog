# 线程池原理分析

首先要明确为什么要使用线程池，使用线程池会带来什么好处？

- 线程是稀缺资源，不能频繁的创建。
- 应当将其放入一个池子中，可以给其他任务进行复用。
- 解耦作用，线程的创建于执行完全分开，方便维护。


## 创建一个线程池

以一个使用较多的 

```java
ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler) 
```

为例：

- 其中的 `corePoolSize` 为线程池的基本大小。
- `maximumPoolSize` 为线程池最大线程大小。
- `keepAliveTime` 和 `unit` 则是线程空闲后的存活时间。
- `workQueue` 用于存放任务的阻塞队列。
- `handler` 当队列和最大线程池都满了之后的饱和策略。

## 处理流程
当提交一个任务到线程池时它的执行流程是怎样的呢？

![](https://ws1.sinaimg.cn/large/006tNbRwgy1fnbzmai8yrj30dw08574s.jpg)

首先第一步会判断核心线程数有没有达到上限，如果没有则创建线程(会获取全局锁)，满了则会将任务丢进阻塞队列。

如果队列也满了则需要判断最大线程数是否达到上限，如果没有则创建线程(获取全局锁)，如果最大线程数也满了则会根据饱和策略处理。

常用的饱和策略有:
- 直接丢弃任务。
- 调用者线程处理。
- 丢弃队列中的最近任务，执行当前任务。

所以当线程池完成预热之后都是将任务放入队列，接着由工作线程一个个从队列里取出执行。

## 合理配置线程池

线程池并不是配置越大越好，而是要根据任务的熟悉来进行划分：

如果是 `CPU` 密集型任务应当分配较少的线程，比如 `CPU` 个数相当的大小。

如果是 IO 密集型任务，由于线程并不是一直在运行，所以可以尽可能的多配置线程，比如 `CPU 个数 * 2` 或 线程数 = CPU核心数/(1-阻塞系数)。

当是一个混合型任务，可以将其拆分为 `CPU` 密集型任务以及 `IO` 密集型任务，这样来分别配置。

注：

**CPU密集型：**即计算密集型，应用需要非常多的CPU计算资源，比如计算文件夹的大小等。计算密集型任务，线程间切换很频繁，加大线程池会增加CPU上下文的切换成本。所以为了让它的优势完全发挥出来，避免过多的线程上下文切换，比较理想方案是：
>     线程数 = CPU核数+1

**IO密集型：**这个很好理解，在web开发中，涉及到大量的网络传输，不仅如此，与数据库，与缓存间的交互也涉及到IO，一旦发生IO，线程就会处于等待状态，当IO结束，数据准备好后，线程才会继续执行。因此从这里可以发现，对于IO密集型的应用，我们可以多设置一些线程池中线程的数量，这样就能让在等待IO的这段时间内，线程可以去做其它事，提高并发处理效率。
>  		线程数 = CPU核心数/(1-阻塞系数)
>     	这个阻塞系数一般为0.8~0.9之间，也可以取0.8或者0.9。套用公式，对于双核CPU来说，它比较理想的线程数就是20，当然这都不是绝对的，需要根据实际情况以及实际业务来调整。
>     	final int poolSize = (int)(cpuCore/(1-0.9))


## 优雅的关闭线程池
线程池提供了两个关闭方法，shutdownNow和shuwdown⽅法。

* shutdownNow⽅法的解释是：线程池拒接收新提交的任务，同时⽴刻关闭线程池，线程池里的任务不再执行。

> 使⽤shutdownNow⽅法，可能会引起报错，使用shutdown方法可能会导致线程关闭不了。所以当我们使⽤shutdownNow⽅法关闭线程池时，一定要对任务里进行异常捕获。

* shutdown⽅法的解释是：线程池拒接收新提交的任务，同时等待线程池⾥的任务执行完毕后关闭线程池。

> 当我们使用shuwdown方法关闭线程池时，一定要确保任务里不会有永久阻塞等待的逻辑，否则线程池就关闭不了。

最后，⼀定要记得shutdownNow和shuwdown调用完，线程池并不是⽴刻就关闭了，要想等待线程池关闭，还需调用awaitTermination⽅法来阻塞等待。