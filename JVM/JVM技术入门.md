

**一次编译，到处运行**

## 从Java代码到字节码
有一个程序MyApp.java，想让它运行。首先需要javac（JDK内置的静态Java语言到字节码编译器）编译，生成相应的可执行字节码MyApp.class。再把Java代码编译成字节码后，你可以通过java命令（通过命令行或startup脚本，使用不使用startup选项都可以）来启动可执行的class文件，从而运行你的应用。这样你的class被加载到运行时（意味着Java虚拟机的运行），程序开始执行。

## 什么是Java虚拟机
* 一个JVM基本上是一个虚拟的执行环境，作为一个字节码指令机器，而用于分配执行任务和执行内存操作通过与底层的交互。
* 一个JVM同样为运行的Java应用管理动态资源。它分配和释放内存，在每个平台上保持一致的线程模型

## JVM组件
1. Java编译器：静态编译与动态编译
静态编译：一个静态编译的例子是javac。静态编译器一次解释输入的代码，输出可执行的形式，你将总能看到结果相同。
动态编译：动态的编译器在编译的过程中，实现更好的指令序列，把一系列的指令替换成更有效的，并消除多余的操作。随着时间的增长，你将收集更多的代码生成数据，做更多更好的编译决定；整个过程就是我们通常称为的代码优化和重编译。

2. 分配会导致垃圾回收
在多线程应用中，多线程不会分配同一个地址空间。每个线程拥有自己的本地缓存空间（TLAB）。在对象的创建与死亡中，会产出很多内存碎片（空间太小而不能生成新对象）。这些碎片分散在堆中，浪费堆空间。最终导致堆内存不够为新对象分配空间而发生out-of-memory异常。

	**如何避免碎片**

	* 在每次基础操作时优化TLAB空间。应用只要有内存分配行为，就需要重新调优；
	* 组织堆分区实现更有效的内存分配。

3. GC算法

	* **引用计数收集器：**会跟踪一个对象指向多少个引用。当一个对象的引用为0时，内存将被立即回收，这是这种方法的优点之一。引用计数方法的难点在于环形数据结构和保持所有的引用即时更新。
	
	* **跟踪收集器：**对仍在引用的对象标记，用已经标记的对象，反复的跟随和标记所有的引用对象。当所有的仍然引用的对象被标记为“live”时，所有的不被标记的空间将被回收。这种方法用于管理环形数据结构，但是在很多情况下收集器在回收不被引用的内存之前，需要等待所有标记完成。

> **垃圾收集的要点：**
> 
> * 不同的垃圾收集算法和实现适应不同的应用程序需要，跟踪垃圾收集器是商业Java虚拟机中使用的最多的垃圾收集器。
> * 并行垃圾收集在执行垃圾收集时并行使用所有资源。它通常是一个stop-the-world垃圾收集器，因此有更高的吞吐量，但是应用程序的工作线程必须等待垃圾收集线程完成，这对应用程序的响应时间有一定影响。
> * 并发垃圾收集在执行收集时，应用程序工作线程仍然在运行。并发垃圾收集器需要在应用程序需要内存之前完成垃圾收集。
> * 分代垃圾收集有助于延迟碎片化，但无法消除碎片化。分代垃圾收集将堆分为两个空间，其中一个空间存放新对象，另一个空间存放老对象。分代垃圾收集适合有很多存活时间很短的小对象的应用程序。
> * 压缩是解决碎片化的唯一方法。多数的垃圾收集器都是以stop-the-world的方式执行压缩的，程序运行时间越久，对象引用越是复杂，对象的大小越是分布不均匀都将导致压缩时间延长。堆的大小也会影响压缩时间，因为可能有更多的活动对象和引用需要更新。
> * 调优有助于延迟内存溢出错误。但是过度调优的结果是僵化的配置。在通过试错的方式开始调优之前，要确保清楚生产环境的负载、应用程序的对象类型以及对象引用的特性。过于僵化的配置很可能无法应付动态负载，因此在设置非动态值时一定要了解这样做的后果。


参考：

http://ifeve.com/jvm-optimize-1/

http://ifeve.com/jvm-compiler/

http://ifeve.com/jvm-3-gc/
